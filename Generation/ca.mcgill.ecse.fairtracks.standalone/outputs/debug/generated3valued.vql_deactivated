import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.newElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Fairtracksmodel class".
 */
private pattern mustInstanceOfFairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Fairtracksmodel class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "Fairtracksmodel class".
 */
private pattern mayInstanceOfFairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFairtracksmodel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTStaticObject class".
 */
private pattern mustInstanceOfFTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTStaticObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTStaticObject class".
 */
private pattern mayInstanceOfFTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTStaticObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObjectWithDistance class".
 */
private pattern mustInstanceOfFTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObjectWithDistance class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObjectWithDistance class".
 */
private pattern mayInstanceOfFTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPlayer class".
 */
private pattern mustInstanceOfFTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPlayer class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPlayer class".
 */
private pattern mayInstanceOfFTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPlayer_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpColorClass class".
 */
private pattern mustInstanceOfFTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpColorClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpColorClass class".
 */
private pattern mayInstanceOfFTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZone class".
 */
private pattern mustInstanceOfFTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZone class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZone class".
 */
private pattern mayInstanceOfFTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZone_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObstacle class".
 */
private pattern mustInstanceOfFTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObstacle class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObstacle class".
 */
private pattern mayInstanceOfFTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObstacle_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZipline class".
 */
private pattern mustInstanceOfFTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZipline class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZipline class".
 */
private pattern mayInstanceOfFTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZipline_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTRealCoordinates class".
 */
private pattern mustInstanceOfFTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTRealCoordinates class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTRealCoordinates class".
 */
private pattern mayInstanceOfFTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistance class".
 */
private pattern mustInstanceOfFTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistance class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistance class".
 */
private pattern mayInstanceOfFTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTDistance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTTrajectory class".
 */
private pattern mustInstanceOfFTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTTrajectory class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTTrajectory class".
 */
private pattern mayInstanceOfFTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTTrajectory_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTState class".
 */
private pattern mustInstanceOfFTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTState class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTState class".
 */
private pattern mayInstanceOfFTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObservation class".
 */
private pattern mustInstanceOfFTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObservation class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObservation class".
 */
private pattern mayInstanceOfFTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObservation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistanceObs class".
 */
private pattern mustInstanceOfFTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistanceObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistanceObs class".
 */
private pattern mayInstanceOfFTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTDistanceObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTHangingObs class".
 */
private pattern mustInstanceOfFTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTHangingObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTHangingObs class".
 */
private pattern mayInstanceOfFTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTHangingObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpObs class".
 */
private pattern mustInstanceOfFTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpObs class".
 */
private pattern mayInstanceOfFTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPickUpObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZoneObs class".
 */
private pattern mustInstanceOfFTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZoneObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZoneObs class".
 */
private pattern mayInstanceOfFTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZoneObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpColor enum".
 */
private pattern mustInstanceOfFTPickUpColor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpColor enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpColor enum".
 */
private pattern mayInstanceOfFTPickUpColor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTPickUpColor_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTRole enum".
 */
private pattern mustInstanceOfFTRole_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTRole enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTRole enum".
 */
private pattern mayInstanceOfFTRole_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTRole_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZoneType enum".
 */
private pattern mustInstanceOfFTZoneType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZoneType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZoneType enum".
 */
private pattern mayInstanceOfFTZoneType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTZoneType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistanceValue enum".
 */
private pattern mustInstanceOfFTDistanceValue_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistanceValue enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistanceValue enum".
 */
private pattern mayInstanceOfFTDistanceValue_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTDistanceValue_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTSize enum".
 */
private pattern mustInstanceOfFTSize_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTSize enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTSize enum".
 */
private pattern mayInstanceOfFTSize_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTSize_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []staticObjects reference Fairtracksmodel(source,target)
 */
private pattern mustInRelationstaticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"staticObjects reference Fairtracksmodel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>staticObjects reference Fairtracksmodel(source,target)
 */
private pattern mayInRelationstaticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,source);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initialDistances reference Fairtracksmodel(source,target)
 */
private pattern mustInRelationinitialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initialDistances reference Fairtracksmodel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initialDistances reference Fairtracksmodel(source,target)
 */
private pattern mayInRelationinitialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,source);
	find mayInstanceOfFTDistance_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []coordinates reference FTStaticObject(source,target)
 */
private pattern mustInRelationcoordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"coordinates reference FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>coordinates reference FTStaticObject(source,target)
 */
private pattern mayInRelationcoordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distanceClass reference FTObjectWithDistance(source,target)
 */
private pattern mustInRelationdistanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distanceClass reference FTObjectWithDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distanceClass reference FTObjectWithDistance(source,target)
 */
private pattern mayInRelationdistanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,source);
	find mayInstanceOfFTDistance_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initiallyInside reference FTPlayer(source,target)
 */
private pattern mustInRelationinitiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initiallyInside reference FTPlayer(source,target)
 */
private pattern mayInRelationinitiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pickUpColor reference FTPlayer(source,target)
 */
private pattern mustInRelationpickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pickUpColor reference FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pickUpColor reference FTPlayer(source,target)
 */
private pattern mayInRelationpickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpickUpColor_reference_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contains reference FTZone(source,target)
 */
private pattern mustInRelationcontains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contains reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contains reference FTZone(source,target)
 */
private pattern mayInRelationcontains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationcontains_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []partiallyOverlaps reference FTZone(source,target)
 */
private pattern mustInRelationpartiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"partiallyOverlaps reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>partiallyOverlaps reference FTZone(source,target)
 */
private pattern mayInRelationpartiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []isAdjacentTo reference FTZone(source,target)
 */
private pattern mustInRelationisAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isAdjacentTo reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>isAdjacentTo reference FTZone(source,target)
 */
private pattern mayInRelationisAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationisAdjacentTo_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disallowedPlayers reference FTZone(source,target)
 */
private pattern mustInRelationdisallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedPlayers reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disallowedPlayers reference FTZone(source,target)
 */
private pattern mayInRelationdisallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTPlayer_class(problem,interpretation,target);
} or {
	find mustInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initiallyInside reference FTObstacle(source,target)
 */
private pattern mustInRelationinitiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initiallyInside reference FTObstacle(source,target)
 */
private pattern mayInRelationinitiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disallowedZones reference FTObstacle(source,target)
 */
private pattern mustInRelationdisallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedZones reference FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disallowedZones reference FTObstacle(source,target)
 */
private pattern mayInRelationdisallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []startZone reference FTZipline(source,target)
 */
private pattern mustInRelationstartZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"startZone reference FTZipline");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>startZone reference FTZipline(source,target)
 */
private pattern mayInRelationstartZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZipline_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstartZone_reference_FTZipline(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationstartZone_reference_FTZipline(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []endZone reference FTZipline(source,target)
 */
private pattern mustInRelationendZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"endZone reference FTZipline");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>endZone reference FTZipline(source,target)
 */
private pattern mayInRelationendZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZipline_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationendZone_reference_FTZipline(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationendZone_reference_FTZipline(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []toObject reference FTDistance(source,target)
 */
private pattern mustInRelationtoObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"toObject reference FTDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>toObject reference FTDistance(source,target)
 */
private pattern mayInRelationtoObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistance_class(problem,interpretation,source);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtoObject_reference_FTDistance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtoObject_reference_FTDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []player reference FTTrajectory(source,target)
 */
private pattern mustInRelationplayer_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"player reference FTTrajectory");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>player reference FTTrajectory(source,target)
 */
private pattern mayInRelationplayer_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTTrajectory_class(problem,interpretation,source);
	find mayInstanceOfFTPlayer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []states reference FTTrajectory(source,target)
 */
private pattern mustInRelationstates_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"states reference FTTrajectory");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>states reference FTTrajectory(source,target)
 */
private pattern mayInRelationstates_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTTrajectory_class(problem,interpretation,source);
	find mayInstanceOfFTState_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstates_reference_FTTrajectory(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []observations reference FTState(source,target)
 */
private pattern mustInRelationobservations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"observations reference FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>observations reference FTState(source,target)
 */
private pattern mayInRelationobservations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	find mayInstanceOfFTObservation_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationobservations_reference_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nextState reference FTState(source,target)
 */
private pattern mustInRelationnextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nextState reference FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nextState reference FTState(source,target)
 */
private pattern mayInRelationnextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	find mayInstanceOfFTState_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnextState_reference_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnextState_reference_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTDistanceObs(source,target)
 */
private pattern mustInRelationobject_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTDistanceObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTDistanceObs(source,target)
 */
private pattern mayInRelationobject_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,source);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTHangingObs(source,target)
 */
private pattern mustInRelationobject_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTHangingObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTHangingObs(source,target)
 */
private pattern mayInRelationobject_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTHangingObs_class(problem,interpretation,source);
	find mayInstanceOfFTZipline_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTHangingObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTHangingObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTPickUpObs(source,target)
 */
private pattern mustInRelationobject_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTPickUpObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTPickUpObs(source,target)
 */
private pattern mayInRelationobject_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,source);
	find mayInstanceOfFTObstacle_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTZoneObs(source,target)
 */
private pattern mustInRelationobject_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTZoneObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTZoneObs(source,target)
 */
private pattern mayInRelationobject_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZoneObs_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTZoneObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTZoneObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute FTStaticObject(source,target)
 */
private pattern mustInRelationname_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute FTStaticObject(source,target)
 */
private pattern mayInRelationname_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []size attribute FTStaticObject(source,target)
 */
private pattern mustInRelationsize_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"size attribute FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>size attribute FTStaticObject(source,target)
 */
private pattern mayInRelationsize_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	find mayInstanceOfFTSize_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []role attribute FTPlayer(source,target)
 */
private pattern mustInRelationrole_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"role attribute FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>role attribute FTPlayer(source,target)
 */
private pattern mayInRelationrole_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTRole_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrole_attribute_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrole_attribute_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []canPickUpObject attribute FTPlayer(source,target)
 */
private pattern mustInRelationcanPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"canPickUpObject attribute FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>canPickUpObject attribute FTPlayer(source,target)
 */
private pattern mayInRelationcanPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []color attribute FTPickUpColorClass(source,target)
 */
private pattern mustInRelationcolor_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTPickUpColorClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>color attribute FTPickUpColorClass(source,target)
 */
private pattern mayInRelationcolor_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute FTZone(source,target)
 */
private pattern mustInRelationtype_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute FTZone(source,target)
 */
private pattern mayInRelationtype_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZoneType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_FTZone(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []isMoveable attribute FTObstacle(source,target)
 */
private pattern mustInRelationisMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isMoveable attribute FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>isMoveable attribute FTObstacle(source,target)
 */
private pattern mayInRelationisMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []color attribute FTObstacle(source,target)
 */
private pattern mustInRelationcolor_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>color attribute FTObstacle(source,target)
 */
private pattern mayInRelationcolor_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posX attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationposX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posX attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationposX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posY attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationposY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posY attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationposY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []sizeX attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationsizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeX attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>sizeX attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationsizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []sizeY attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationsizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeY attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>sizeY attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationsizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance attribute FTDistance(source,target)
 */
private pattern mustInRelationdistance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance attribute FTDistance(source,target)
 */
private pattern mayInRelationdistance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistance_class(problem,interpretation,source);
	find mayInstanceOfFTDistanceValue_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_attribute_FTDistance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_attribute_FTDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute FTState(source,target)
 */
private pattern mustInRelationname_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute FTState(source,target)
 */
private pattern mayInRelationname_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posX attribute FTState(source,target)
 */
private pattern mustInRelationposX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posX attribute FTState(source,target)
 */
private pattern mayInRelationposX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposX_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposX_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posY attribute FTState(source,target)
 */
private pattern mustInRelationposY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posY attribute FTState(source,target)
 */
private pattern mayInRelationposY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposY_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposY_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance attribute FTDistanceObs(source,target)
 */
private pattern mustInRelationdistance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistanceObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance attribute FTDistanceObs(source,target)
 */
private pattern mayInRelationdistance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,source);
	find mayInstanceOfFTDistanceValue_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries helperFTPlayer
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries helperFTZone
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTZone_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTZone_class(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries helperFTObstacle
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTObstacle_class(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries helperFTZipline
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTZipline_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTZipline_class(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries countStaticObject
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTStaticObject_class(problem,interpretation,var_o1);
	neg find mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(problem,interpretation,var_o1);
	neg find mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(problem,interpretation,var_o1);
	neg find mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(problem,interpretation,var_o1);
	neg find mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZipline(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTStaticObject_class(problem,interpretation,var_o1);
	neg find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(problem,interpretation,var_o1);
	neg find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(problem,interpretation,var_o1);
	neg find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(problem,interpretation,var_o1);
	neg find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZipline(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTStaticObject_class(problem,interpretation,var_o1);
	neg find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(problem,interpretation,var_o1);
	neg find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(problem,interpretation,var_o1);
	neg find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(problem,interpretation,var_o1);
	neg find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZipline(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries countRealCoordinates
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,var_r1);
	// r1 is exported
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,var_r1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,var_r1);
	// r1 is exported
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,var_r1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,var_r1);
	// r1 is exported
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,var_r1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries countObjectWithDistance
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,var_o1);
	neg find mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(problem,interpretation,var_o1);
	neg find mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(problem,interpretation,var_o1);
	neg find mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,var_o1);
	neg find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(problem,interpretation,var_o1);
	neg find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(problem,interpretation,var_o1);
	neg find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,var_o1);
	neg find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTPlayer(problem,interpretation,var_o1);
	neg find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTZone(problem,interpretation,var_o1);
	neg find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_helperFTObstacle(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries countPlayer
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o2);
	neg find mayEquivalent(problem, interpretation, var_o1, var_o2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_o2);
	var_o1 != var_o2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o1);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_o2);
	var_o1 != var_o2;
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries countZone
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTZone_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTZone_class(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZone_class(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries countObstacle
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o2);
	neg find mayEquivalent(problem, interpretation, var_o1, var_o2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	find mayInstanceOfFTObstacle_class(problem,interpretation,var_o2);
	var_o1 != var_o2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o1);
	find mustInstanceOfFTObstacle_class(problem,interpretation,var_o2);
	var_o1 != var_o2;
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries countZipline
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTZipline_class(problem,interpretation,var_o1);
	// o1 is exported
	find mayInstanceOfFTZipline_class(problem,interpretation,var_o1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
	// o1 is exported
	find mustInstanceOfFTZipline_class(problem,interpretation,var_o1);
}
// Must, May and Current queries for pattern ca mcgill ecse fairtracks queries PlayerDistinctRole
private pattern mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_PlayerDistinctRole(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_p1, var_p2, var_commonRole)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p1);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p2);
	// type constraint is enforced by construction
	// p1 is exported
	// p2 is exported
	// commonRole is exported
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p1);
	find mustInRelationrole_attribute_FTPlayer(problem,interpretation,var_p1,var_virtual0);
	// type constraint is enforced by construction
	var_virtual0 == var_commonRole;
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p2);
	find mustInRelationrole_attribute_FTPlayer(problem,interpretation,var_p2,var_virtual1);
	// type constraint is enforced by construction
	var_virtual1 == var_commonRole;
	neg find mayEquivalent(problem, interpretation, var_p1, var_p2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_PlayerDistinctRole(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_p1, var_p2, var_commonRole)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_p1);
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_p2);
	// type constraint is enforced by construction
	// p1 is exported
	// p2 is exported
	// commonRole is exported
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_p1);
	find mayInRelationrole_attribute_FTPlayer(problem,interpretation,var_p1,var_virtual0);
	// type constraint is enforced by construction
	find mayEquivalent(problem, interpretation, var_virtual0, var_commonRole);
	find mayInstanceOfFTPlayer_class(problem,interpretation,var_p2);
	find mayInRelationrole_attribute_FTPlayer(problem,interpretation,var_p2,var_virtual1);
	// type constraint is enforced by construction
	find mayEquivalent(problem, interpretation, var_virtual1, var_commonRole);
	var_p1 != var_p2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_PlayerDistinctRole(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_p1, var_p2, var_commonRole)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p1);
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p2);
	// type constraint is enforced by construction
	// p1 is exported
	// p2 is exported
	// commonRole is exported
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p1);
	find mustInRelationrole_attribute_FTPlayer(problem,interpretation,var_p1,var_virtual0);
	// type constraint is enforced by construction
	var_virtual0 == var_commonRole;
	find mustInstanceOfFTPlayer_class(problem,interpretation,var_p2);
	find mustInRelationrole_attribute_FTPlayer(problem,interpretation,var_p2,var_virtual1);
	// type constraint is enforced by construction
	var_virtual1 == var_commonRole;
	var_p1 != var_p2;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,source,target); }or
	
	{ find mustInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,source,target); }or
	
	{ find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,target); }or
	
	{ find mustInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,source,target); }or
	
	{ find mustInRelationpickUpColor_reference_FTPlayer(problem,interpretation,source,target); }or
	
	{ find mustInRelationstates_reference_FTTrajectory(problem,interpretation,source,target); }or
	
	{ find mustInRelationobservations_reference_FTState(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countStaticObject(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countStaticObject(problem,interpretation,var_o1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countRealCoordinates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countRealCoordinates(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countObjectWithDistance(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObjectWithDistance(problem,interpretation,var_o1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countPlayer(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countPlayer(problem,interpretation,var_o1,var_o2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countZone(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZone(problem,interpretation,var_o1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countObstacle(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObstacle(problem,interpretation,var_o1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countZipline(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZipline(problem,interpretation,var_o1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_fairtracks_queries_PlayerDistinctRole(problem:LogicProblem, interpretation:PartialInterpretation,
	var_p1, var_p2, var_commonRole)
{
	find mustInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_PlayerDistinctRole(problem,interpretation,var_p1,var_p2,var_commonRole);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countStaticObject(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countStaticObject(problem,interpretation,var_o1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countRealCoordinates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countRealCoordinates(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countObjectWithDistance(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObjectWithDistance(problem,interpretation,var_o1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countPlayer(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countPlayer(problem,interpretation,var_o1,var_o2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countZone(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZone(problem,interpretation,var_o1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countObstacle(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countObstacle(problem,interpretation,var_o1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_countZipline(problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_countZipline(problem,interpretation,var_o1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_fairtracks_queries_PlayerDistinctRole(problem:LogicProblem, interpretation:PartialInterpretation,
	var_p1, var_p2, var_commonRole)
{
	find currentInRelation_pattern_ca_mcgill_ecse_fairtracks_queries_PlayerDistinctRole(problem,interpretation,var_p1,var_p2,var_commonRole);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTHangingObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZipline_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObstacle_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZoneObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPickUpObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObservation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTDistance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZone_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTTrajectory_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FTObservation_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObservation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTObservation_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObservation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObservation class");
	find mayInstanceOfFTObservation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObstacle_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObstacle class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTObstacle_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObstacle_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObstacle class");
	find mayInstanceOfFTObstacle_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObjectWithDistance_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObjectWithDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObjectWithDistance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObjectWithDistance class");
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTRealCoordinates_class_by_coordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTRealCoordinates class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"coordinates reference FTStaticObject");
	find mustInstanceOfFTStaticObject_class(problem,interpretation,container);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,newObject);
	find mayInRelationcoordinates_reference_FTStaticObject(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTRealCoordinates_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTRealCoordinates class");
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class_by_initialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"initialDistances reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class_by_distanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"distanceClass reference FTObjectWithDistance");
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,container);
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Fairtracksmodel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Fairtracksmodel class");
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZone_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZone class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTZone_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZone_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZone class");
	find mayInstanceOfFTZone_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTStaticObject_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTStaticObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTStaticObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTStaticObject class");
	find mayInstanceOfFTStaticObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpObs class");
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTState_class_by_states_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"states reference FTTrajectory");
	find mustInstanceOfFTTrajectory_class(problem,interpretation,container);
	find mayInstanceOfFTState_class(problem,interpretation,newObject);
	find mayInRelationstates_reference_FTTrajectory(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTState class");
	find mayInstanceOfFTState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTTrajectory_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTTrajectory class");
	find mayInstanceOfFTTrajectory_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZipline_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZipline class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTZipline_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZipline_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZipline class");
	find mayInstanceOfFTZipline_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPlayer_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPlayer class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTPlayer_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPlayer_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPlayer class");
	find mayInstanceOfFTPlayer_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZoneObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZoneObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTZoneObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZoneObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZoneObs class");
	find mayInstanceOfFTZoneObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistanceObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistanceObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistanceObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistanceObs class");
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTHangingObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTHangingObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTHangingObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTHangingObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTHangingObs class");
	find mayInstanceOfFTHangingObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpColorClass_class_by_pickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpColorClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pickUpColor reference FTPlayer");
	find mustInstanceOfFTPlayer_class(problem,interpretation,container);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,newObject);
	find mayInRelationpickUpColor_reference_FTPlayer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpColorClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpColorClass class");
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
}
pattern refineTypeTo_FTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
}
pattern refineTypeTo_Fairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
}
pattern refineTypeTo_FTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
}
pattern refineTypeTo_FTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_initiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_contains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contains reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationcontains_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationcontains_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_partiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"partiallyOverlaps reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_isAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isAdjacentTo reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationisAdjacentTo_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationisAdjacentTo_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_disallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedPlayers reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTPlayer_class(problem,interpretation,to);
	find mayInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_initiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_disallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedZones reference FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_startZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"startZone reference FTZipline");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZipline_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationstartZone_reference_FTZipline(problem,interpretation,from,to);
	neg find mustInRelationstartZone_reference_FTZipline(problem,interpretation,from,to);
}
pattern refineRelation_endZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"endZone reference FTZipline");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZipline_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationendZone_reference_FTZipline(problem,interpretation,from,to);
	neg find mustInRelationendZone_reference_FTZipline(problem,interpretation,from,to);
}
pattern refineRelation_toObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"toObject reference FTDistance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistance_class(problem,interpretation,from);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,to);
	find mayInRelationtoObject_reference_FTDistance(problem,interpretation,from,to);
	neg find mustInRelationtoObject_reference_FTDistance(problem,interpretation,from,to);
}
pattern refineRelation_player_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"player reference FTTrajectory");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTTrajectory_class(problem,interpretation,from);
	find mustInstanceOfFTPlayer_class(problem,interpretation,to);
	find mayInRelationplayer_reference_FTTrajectory(problem,interpretation,from,to);
	neg find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,from,to);
}
pattern refineRelation_nextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nextState reference FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	find mustInstanceOfFTState_class(problem,interpretation,to);
	find mayInRelationnextState_reference_FTState(problem,interpretation,from,to);
	neg find mustInRelationnextState_reference_FTState(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTDistanceObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,from);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTDistanceObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTHangingObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTHangingObs_class(problem,interpretation,from);
	find mustInstanceOfFTZipline_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTHangingObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTHangingObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTPickUpObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPickUpObs_class(problem,interpretation,from);
	find mustInstanceOfFTObstacle_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTPickUpObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTZoneObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZoneObs_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTZoneObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTZoneObs(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTStaticObject");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_FTStaticObject(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_FTStaticObject(problem,interpretation,from,to);
}
pattern refineRelation_size_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"size attribute FTStaticObject");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,from);
	find mustInstanceOfFTSize_enum(problem,interpretation,to);
	find mayInRelationsize_attribute_FTStaticObject(problem,interpretation,from,to);
	neg find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,from,to);
}
pattern refineRelation_role_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"role attribute FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	find mustInstanceOfFTRole_enum(problem,interpretation,to);
	find mayInRelationrole_attribute_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationrole_attribute_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_canPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"canPickUpObject attribute FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_color_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTPickUpColorClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,from);
	find mustInstanceOfFTPickUpColor_enum(problem,interpretation,to);
	find mayInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,from,to);
	neg find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZoneType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_FTZone(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_isMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isMoveable attribute FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationisMoveable_attribute_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_color_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTPickUpColor_enum(problem,interpretation,to);
	find mayInRelationcolor_attribute_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_posX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposX_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_posY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposY_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_sizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeX attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_sizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeY attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_distance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistance_class(problem,interpretation,from);
	find mustInstanceOfFTDistanceValue_enum(problem,interpretation,to);
	find mayInRelationdistance_attribute_FTDistance(problem,interpretation,from,to);
	neg find mustInRelationdistance_attribute_FTDistance(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_posX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposX_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationposX_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_posY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposY_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationposY_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_distance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistanceObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,from);
	find mustInstanceOfFTDistanceValue_enum(problem,interpretation,to);
	find mayInRelationdistance_attribute_FTDistanceObs(problem,interpretation,from,to);
	neg find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.newElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Fairtracksmodel class".
 */
private pattern mustInstanceOfFairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Fairtracksmodel class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "Fairtracksmodel class".
 */
private pattern mayInstanceOfFairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFairtracksmodel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTStaticObject class".
 */
private pattern mustInstanceOfFTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTStaticObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTStaticObject class".
 */
private pattern mayInstanceOfFTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTStaticObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObjectWithDistance class".
 */
private pattern mustInstanceOfFTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObjectWithDistance class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObjectWithDistance class".
 */
private pattern mayInstanceOfFTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPlayer class".
 */
private pattern mustInstanceOfFTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPlayer class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPlayer class".
 */
private pattern mayInstanceOfFTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPlayer_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpColorClass class".
 */
private pattern mustInstanceOfFTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpColorClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpColorClass class".
 */
private pattern mayInstanceOfFTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZone class".
 */
private pattern mustInstanceOfFTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZone class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZone class".
 */
private pattern mayInstanceOfFTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZone_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObstacle class".
 */
private pattern mustInstanceOfFTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObstacle class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObstacle class".
 */
private pattern mayInstanceOfFTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObstacle_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZipline class".
 */
private pattern mustInstanceOfFTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZipline class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZipline class".
 */
private pattern mayInstanceOfFTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZipline_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTRealCoordinates class".
 */
private pattern mustInstanceOfFTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTRealCoordinates class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTRealCoordinates class".
 */
private pattern mayInstanceOfFTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistance class".
 */
private pattern mustInstanceOfFTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistance class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistance class".
 */
private pattern mayInstanceOfFTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTDistance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTTrajectory class".
 */
private pattern mustInstanceOfFTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTTrajectory class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTTrajectory class".
 */
private pattern mayInstanceOfFTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTTrajectory_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTState class".
 */
private pattern mustInstanceOfFTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTState class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTState class".
 */
private pattern mayInstanceOfFTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObservation class".
 */
private pattern mustInstanceOfFTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObservation class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObservation class".
 */
private pattern mayInstanceOfFTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObservation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistanceObs class".
 */
private pattern mustInstanceOfFTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistanceObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistanceObs class".
 */
private pattern mayInstanceOfFTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTDistanceObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTHangingObs class".
 */
private pattern mustInstanceOfFTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTHangingObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTHangingObs class".
 */
private pattern mayInstanceOfFTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTHangingObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpObs class".
 */
private pattern mustInstanceOfFTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpObs class".
 */
private pattern mayInstanceOfFTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPickUpObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZoneObs class".
 */
private pattern mustInstanceOfFTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZoneObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZoneObs class".
 */
private pattern mayInstanceOfFTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZoneObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpColor enum".
 */
private pattern mustInstanceOfFTPickUpColor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpColor enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpColor enum".
 */
private pattern mayInstanceOfFTPickUpColor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTPickUpColor_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTRole enum".
 */
private pattern mustInstanceOfFTRole_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTRole enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTRole enum".
 */
private pattern mayInstanceOfFTRole_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTRole_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZoneType enum".
 */
private pattern mustInstanceOfFTZoneType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZoneType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZoneType enum".
 */
private pattern mayInstanceOfFTZoneType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTZoneType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistanceValue enum".
 */
private pattern mustInstanceOfFTDistanceValue_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistanceValue enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistanceValue enum".
 */
private pattern mayInstanceOfFTDistanceValue_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTDistanceValue_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTSize enum".
 */
private pattern mustInstanceOfFTSize_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTSize enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTSize enum".
 */
private pattern mayInstanceOfFTSize_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTSize_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []staticObjects reference Fairtracksmodel(source,target)
 */
private pattern mustInRelationstaticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"staticObjects reference Fairtracksmodel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>staticObjects reference Fairtracksmodel(source,target)
 */
private pattern mayInRelationstaticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,source);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initialDistances reference Fairtracksmodel(source,target)
 */
private pattern mustInRelationinitialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initialDistances reference Fairtracksmodel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initialDistances reference Fairtracksmodel(source,target)
 */
private pattern mayInRelationinitialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,source);
	find mayInstanceOfFTDistance_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []coordinates reference FTStaticObject(source,target)
 */
private pattern mustInRelationcoordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"coordinates reference FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>coordinates reference FTStaticObject(source,target)
 */
private pattern mayInRelationcoordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distanceClass reference FTObjectWithDistance(source,target)
 */
private pattern mustInRelationdistanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distanceClass reference FTObjectWithDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distanceClass reference FTObjectWithDistance(source,target)
 */
private pattern mayInRelationdistanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,source);
	find mayInstanceOfFTDistance_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initiallyInside reference FTPlayer(source,target)
 */
private pattern mustInRelationinitiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initiallyInside reference FTPlayer(source,target)
 */
private pattern mayInRelationinitiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pickUpColor reference FTPlayer(source,target)
 */
private pattern mustInRelationpickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pickUpColor reference FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pickUpColor reference FTPlayer(source,target)
 */
private pattern mayInRelationpickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpickUpColor_reference_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contains reference FTZone(source,target)
 */
private pattern mustInRelationcontains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contains reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contains reference FTZone(source,target)
 */
private pattern mayInRelationcontains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationcontains_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []partiallyOverlaps reference FTZone(source,target)
 */
private pattern mustInRelationpartiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"partiallyOverlaps reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>partiallyOverlaps reference FTZone(source,target)
 */
private pattern mayInRelationpartiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []isAdjacentTo reference FTZone(source,target)
 */
private pattern mustInRelationisAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isAdjacentTo reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>isAdjacentTo reference FTZone(source,target)
 */
private pattern mayInRelationisAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationisAdjacentTo_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disallowedPlayers reference FTZone(source,target)
 */
private pattern mustInRelationdisallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedPlayers reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disallowedPlayers reference FTZone(source,target)
 */
private pattern mayInRelationdisallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTPlayer_class(problem,interpretation,target);
} or {
	find mustInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initiallyInside reference FTObstacle(source,target)
 */
private pattern mustInRelationinitiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initiallyInside reference FTObstacle(source,target)
 */
private pattern mayInRelationinitiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disallowedZones reference FTObstacle(source,target)
 */
private pattern mustInRelationdisallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedZones reference FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disallowedZones reference FTObstacle(source,target)
 */
private pattern mayInRelationdisallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []startZone reference FTZipline(source,target)
 */
private pattern mustInRelationstartZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"startZone reference FTZipline");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>startZone reference FTZipline(source,target)
 */
private pattern mayInRelationstartZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZipline_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstartZone_reference_FTZipline(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationstartZone_reference_FTZipline(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []endZone reference FTZipline(source,target)
 */
private pattern mustInRelationendZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"endZone reference FTZipline");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>endZone reference FTZipline(source,target)
 */
private pattern mayInRelationendZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZipline_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationendZone_reference_FTZipline(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationendZone_reference_FTZipline(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []toObject reference FTDistance(source,target)
 */
private pattern mustInRelationtoObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"toObject reference FTDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>toObject reference FTDistance(source,target)
 */
private pattern mayInRelationtoObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistance_class(problem,interpretation,source);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtoObject_reference_FTDistance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtoObject_reference_FTDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []player reference FTTrajectory(source,target)
 */
private pattern mustInRelationplayer_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"player reference FTTrajectory");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>player reference FTTrajectory(source,target)
 */
private pattern mayInRelationplayer_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTTrajectory_class(problem,interpretation,source);
	find mayInstanceOfFTPlayer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []states reference FTTrajectory(source,target)
 */
private pattern mustInRelationstates_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"states reference FTTrajectory");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>states reference FTTrajectory(source,target)
 */
private pattern mayInRelationstates_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTTrajectory_class(problem,interpretation,source);
	find mayInstanceOfFTState_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstates_reference_FTTrajectory(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []observations reference FTState(source,target)
 */
private pattern mustInRelationobservations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"observations reference FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>observations reference FTState(source,target)
 */
private pattern mayInRelationobservations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	find mayInstanceOfFTObservation_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationobservations_reference_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nextState reference FTState(source,target)
 */
private pattern mustInRelationnextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nextState reference FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nextState reference FTState(source,target)
 */
private pattern mayInRelationnextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	find mayInstanceOfFTState_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnextState_reference_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnextState_reference_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTDistanceObs(source,target)
 */
private pattern mustInRelationobject_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTDistanceObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTDistanceObs(source,target)
 */
private pattern mayInRelationobject_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,source);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTHangingObs(source,target)
 */
private pattern mustInRelationobject_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTHangingObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTHangingObs(source,target)
 */
private pattern mayInRelationobject_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTHangingObs_class(problem,interpretation,source);
	find mayInstanceOfFTZipline_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTHangingObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTHangingObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTPickUpObs(source,target)
 */
private pattern mustInRelationobject_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTPickUpObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTPickUpObs(source,target)
 */
private pattern mayInRelationobject_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,source);
	find mayInstanceOfFTObstacle_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTZoneObs(source,target)
 */
private pattern mustInRelationobject_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTZoneObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTZoneObs(source,target)
 */
private pattern mayInRelationobject_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZoneObs_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTZoneObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTZoneObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute FTStaticObject(source,target)
 */
private pattern mustInRelationname_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute FTStaticObject(source,target)
 */
private pattern mayInRelationname_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []size attribute FTStaticObject(source,target)
 */
private pattern mustInRelationsize_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"size attribute FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>size attribute FTStaticObject(source,target)
 */
private pattern mayInRelationsize_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	find mayInstanceOfFTSize_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []role attribute FTPlayer(source,target)
 */
private pattern mustInRelationrole_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"role attribute FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>role attribute FTPlayer(source,target)
 */
private pattern mayInRelationrole_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTRole_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrole_attribute_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrole_attribute_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []canPickUpObject attribute FTPlayer(source,target)
 */
private pattern mustInRelationcanPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"canPickUpObject attribute FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>canPickUpObject attribute FTPlayer(source,target)
 */
private pattern mayInRelationcanPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []color attribute FTPickUpColorClass(source,target)
 */
private pattern mustInRelationcolor_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTPickUpColorClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>color attribute FTPickUpColorClass(source,target)
 */
private pattern mayInRelationcolor_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute FTZone(source,target)
 */
private pattern mustInRelationtype_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute FTZone(source,target)
 */
private pattern mayInRelationtype_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZoneType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_FTZone(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []isMoveable attribute FTObstacle(source,target)
 */
private pattern mustInRelationisMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isMoveable attribute FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>isMoveable attribute FTObstacle(source,target)
 */
private pattern mayInRelationisMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []color attribute FTObstacle(source,target)
 */
private pattern mustInRelationcolor_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>color attribute FTObstacle(source,target)
 */
private pattern mayInRelationcolor_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posX attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationposX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posX attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationposX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posY attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationposY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posY attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationposY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []sizeX attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationsizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeX attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>sizeX attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationsizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []sizeY attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationsizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeY attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>sizeY attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationsizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance attribute FTDistance(source,target)
 */
private pattern mustInRelationdistance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance attribute FTDistance(source,target)
 */
private pattern mayInRelationdistance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistance_class(problem,interpretation,source);
	find mayInstanceOfFTDistanceValue_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_attribute_FTDistance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_attribute_FTDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute FTState(source,target)
 */
private pattern mustInRelationname_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute FTState(source,target)
 */
private pattern mayInRelationname_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posX attribute FTState(source,target)
 */
private pattern mustInRelationposX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posX attribute FTState(source,target)
 */
private pattern mayInRelationposX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposX_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposX_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posY attribute FTState(source,target)
 */
private pattern mustInRelationposY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posY attribute FTState(source,target)
 */
private pattern mayInRelationposY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposY_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposY_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance attribute FTDistanceObs(source,target)
 */
private pattern mustInRelationdistance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistanceObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance attribute FTDistanceObs(source,target)
 */
private pattern mayInRelationdistance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,source);
	find mayInstanceOfFTDistanceValue_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,source,target); }or
	
	{ find mustInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,source,target); }or
	
	{ find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,target); }or
	
	{ find mustInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,source,target); }or
	
	{ find mustInRelationpickUpColor_reference_FTPlayer(problem,interpretation,source,target); }or
	
	{ find mustInRelationstates_reference_FTTrajectory(problem,interpretation,source,target); }or
	
	{ find mustInRelationobservations_reference_FTState(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTHangingObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZipline_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObstacle_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZoneObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPickUpObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObservation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTDistance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZone_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTTrajectory_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FTObstacle_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObstacle class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTObstacle_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObstacle_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObstacle class");
	find mayInstanceOfFTObstacle_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObjectWithDistance_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObjectWithDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObjectWithDistance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObjectWithDistance class");
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTState_class_by_states_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"states reference FTTrajectory");
	find mustInstanceOfFTTrajectory_class(problem,interpretation,container);
	find mayInstanceOfFTState_class(problem,interpretation,newObject);
	find mayInRelationstates_reference_FTTrajectory(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTState class");
	find mayInstanceOfFTState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTStaticObject_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTStaticObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTStaticObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTStaticObject class");
	find mayInstanceOfFTStaticObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObservation_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObservation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTObservation_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObservation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObservation class");
	find mayInstanceOfFTObservation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTRealCoordinates_class_by_coordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTRealCoordinates class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"coordinates reference FTStaticObject");
	find mustInstanceOfFTStaticObject_class(problem,interpretation,container);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,newObject);
	find mayInRelationcoordinates_reference_FTStaticObject(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTRealCoordinates_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTRealCoordinates class");
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTTrajectory_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTTrajectory class");
	find mayInstanceOfFTTrajectory_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Fairtracksmodel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Fairtracksmodel class");
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpObs class");
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpColorClass_class_by_pickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpColorClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pickUpColor reference FTPlayer");
	find mustInstanceOfFTPlayer_class(problem,interpretation,container);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,newObject);
	find mayInRelationpickUpColor_reference_FTPlayer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpColorClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpColorClass class");
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZipline_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZipline class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTZipline_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZipline_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZipline class");
	find mayInstanceOfFTZipline_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistanceObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistanceObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistanceObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistanceObs class");
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZoneObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZoneObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTZoneObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZoneObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZoneObs class");
	find mayInstanceOfFTZoneObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class_by_initialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"initialDistances reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class_by_distanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"distanceClass reference FTObjectWithDistance");
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,container);
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPlayer_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPlayer class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTPlayer_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPlayer_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPlayer class");
	find mayInstanceOfFTPlayer_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTHangingObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTHangingObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTHangingObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTHangingObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTHangingObs class");
	find mayInstanceOfFTHangingObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZone_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZone class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTZone_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZone_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZone class");
	find mayInstanceOfFTZone_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
}
pattern refineTypeTo_FTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
}
pattern refineTypeTo_FTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
}
pattern refineTypeTo_FTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
}
pattern refineTypeTo_FTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_FTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
}
pattern refineTypeTo_Fairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
}
pattern refineTypeTo_FTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
}
pattern refineTypeTo_FTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
}
pattern refineTypeTo_FTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_initiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_contains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contains reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationcontains_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationcontains_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_partiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"partiallyOverlaps reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_isAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isAdjacentTo reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationisAdjacentTo_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationisAdjacentTo_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_disallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedPlayers reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTPlayer_class(problem,interpretation,to);
	find mayInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_initiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_disallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedZones reference FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_startZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"startZone reference FTZipline");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZipline_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationstartZone_reference_FTZipline(problem,interpretation,from,to);
	neg find mustInRelationstartZone_reference_FTZipline(problem,interpretation,from,to);
}
pattern refineRelation_endZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"endZone reference FTZipline");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZipline_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationendZone_reference_FTZipline(problem,interpretation,from,to);
	neg find mustInRelationendZone_reference_FTZipline(problem,interpretation,from,to);
}
pattern refineRelation_toObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"toObject reference FTDistance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistance_class(problem,interpretation,from);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,to);
	find mayInRelationtoObject_reference_FTDistance(problem,interpretation,from,to);
	neg find mustInRelationtoObject_reference_FTDistance(problem,interpretation,from,to);
}
pattern refineRelation_player_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"player reference FTTrajectory");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTTrajectory_class(problem,interpretation,from);
	find mustInstanceOfFTPlayer_class(problem,interpretation,to);
	find mayInRelationplayer_reference_FTTrajectory(problem,interpretation,from,to);
	neg find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,from,to);
}
pattern refineRelation_nextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nextState reference FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	find mustInstanceOfFTState_class(problem,interpretation,to);
	find mayInRelationnextState_reference_FTState(problem,interpretation,from,to);
	neg find mustInRelationnextState_reference_FTState(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTDistanceObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,from);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTDistanceObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTHangingObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTHangingObs_class(problem,interpretation,from);
	find mustInstanceOfFTZipline_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTHangingObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTHangingObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTPickUpObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPickUpObs_class(problem,interpretation,from);
	find mustInstanceOfFTObstacle_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTPickUpObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTZoneObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZoneObs_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTZoneObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTZoneObs(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTStaticObject");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_FTStaticObject(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_FTStaticObject(problem,interpretation,from,to);
}
pattern refineRelation_size_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"size attribute FTStaticObject");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,from);
	find mustInstanceOfFTSize_enum(problem,interpretation,to);
	find mayInRelationsize_attribute_FTStaticObject(problem,interpretation,from,to);
	neg find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,from,to);
}
pattern refineRelation_role_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"role attribute FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	find mustInstanceOfFTRole_enum(problem,interpretation,to);
	find mayInRelationrole_attribute_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationrole_attribute_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_canPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"canPickUpObject attribute FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_color_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTPickUpColorClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,from);
	find mustInstanceOfFTPickUpColor_enum(problem,interpretation,to);
	find mayInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,from,to);
	neg find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZoneType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_FTZone(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_isMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isMoveable attribute FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationisMoveable_attribute_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_color_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTPickUpColor_enum(problem,interpretation,to);
	find mayInRelationcolor_attribute_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_posX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposX_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_posY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposY_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_sizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeX attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_sizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeY attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_distance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistance_class(problem,interpretation,from);
	find mustInstanceOfFTDistanceValue_enum(problem,interpretation,to);
	find mayInRelationdistance_attribute_FTDistance(problem,interpretation,from,to);
	neg find mustInRelationdistance_attribute_FTDistance(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_posX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposX_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationposX_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_posY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposY_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationposY_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_distance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistanceObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,from);
	find mustInstanceOfFTDistanceValue_enum(problem,interpretation,to);
	find mayInRelationdistance_attribute_FTDistanceObs(problem,interpretation,from,to);
	neg find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.newElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Fairtracksmodel class".
 */
private pattern mustInstanceOfFairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Fairtracksmodel class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "Fairtracksmodel class".
 */
private pattern mayInstanceOfFairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFairtracksmodel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTStaticObject class".
 */
private pattern mustInstanceOfFTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTStaticObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTStaticObject class".
 */
private pattern mayInstanceOfFTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTStaticObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObjectWithDistance class".
 */
private pattern mustInstanceOfFTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObjectWithDistance class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObjectWithDistance class".
 */
private pattern mayInstanceOfFTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPlayer class".
 */
private pattern mustInstanceOfFTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPlayer class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPlayer class".
 */
private pattern mayInstanceOfFTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPlayer_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpColorClass class".
 */
private pattern mustInstanceOfFTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpColorClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpColorClass class".
 */
private pattern mayInstanceOfFTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZone class".
 */
private pattern mustInstanceOfFTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZone class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZone class".
 */
private pattern mayInstanceOfFTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZone_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObstacle class".
 */
private pattern mustInstanceOfFTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObstacle class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObstacle class".
 */
private pattern mayInstanceOfFTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObstacle_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZipline class".
 */
private pattern mustInstanceOfFTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZipline class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZipline class".
 */
private pattern mayInstanceOfFTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZipline_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTRealCoordinates class".
 */
private pattern mustInstanceOfFTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTRealCoordinates class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTRealCoordinates class".
 */
private pattern mayInstanceOfFTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistance class".
 */
private pattern mustInstanceOfFTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistance class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistance class".
 */
private pattern mayInstanceOfFTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTDistance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTTrajectory class".
 */
private pattern mustInstanceOfFTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTTrajectory class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTTrajectory class".
 */
private pattern mayInstanceOfFTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTTrajectory_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTState class".
 */
private pattern mustInstanceOfFTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTState class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTState class".
 */
private pattern mayInstanceOfFTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTObservation class".
 */
private pattern mustInstanceOfFTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTObservation class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTObservation class".
 */
private pattern mayInstanceOfFTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTObservation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistanceObs class".
 */
private pattern mustInstanceOfFTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistanceObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistanceObs class".
 */
private pattern mayInstanceOfFTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTDistanceObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTHangingObs class".
 */
private pattern mustInstanceOfFTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTHangingObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTHangingObs class".
 */
private pattern mayInstanceOfFTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTHangingObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpObs class".
 */
private pattern mustInstanceOfFTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpObs class".
 */
private pattern mayInstanceOfFTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTPickUpObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZoneObs class".
 */
private pattern mustInstanceOfFTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZoneObs class");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZoneObs class".
 */
private pattern mayInstanceOfFTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
} or
{ find mustInstanceOfFTZoneObs_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTPickUpColor enum".
 */
private pattern mustInstanceOfFTPickUpColor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTPickUpColor enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTPickUpColor enum".
 */
private pattern mayInstanceOfFTPickUpColor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTPickUpColor_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTRole enum".
 */
private pattern mustInstanceOfFTRole_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTRole enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTRole enum".
 */
private pattern mayInstanceOfFTRole_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTRole_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTZoneType enum".
 */
private pattern mustInstanceOfFTZoneType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTZoneType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTZoneType enum".
 */
private pattern mayInstanceOfFTZoneType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTZoneType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTDistanceValue enum".
 */
private pattern mustInstanceOfFTDistanceValue_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTDistanceValue enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTDistanceValue enum".
 */
private pattern mayInstanceOfFTDistanceValue_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTDistanceValue_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FTSize enum".
 */
private pattern mustInstanceOfFTSize_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FTSize enum");
	find directInstanceOf(problem,interpretation,element,type);
}
/**
 * An element may be an instance of type "FTSize enum".
 */
private pattern mayInstanceOfFTSize_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFTSize_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []staticObjects reference Fairtracksmodel(source,target)
 */
private pattern mustInRelationstaticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"staticObjects reference Fairtracksmodel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>staticObjects reference Fairtracksmodel(source,target)
 */
private pattern mayInRelationstaticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,source);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initialDistances reference Fairtracksmodel(source,target)
 */
private pattern mustInRelationinitialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initialDistances reference Fairtracksmodel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initialDistances reference Fairtracksmodel(source,target)
 */
private pattern mayInRelationinitialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,source);
	find mayInstanceOfFTDistance_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []coordinates reference FTStaticObject(source,target)
 */
private pattern mustInRelationcoordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"coordinates reference FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>coordinates reference FTStaticObject(source,target)
 */
private pattern mayInRelationcoordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distanceClass reference FTObjectWithDistance(source,target)
 */
private pattern mustInRelationdistanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distanceClass reference FTObjectWithDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distanceClass reference FTObjectWithDistance(source,target)
 */
private pattern mayInRelationdistanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,source);
	find mayInstanceOfFTDistance_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initiallyInside reference FTPlayer(source,target)
 */
private pattern mustInRelationinitiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initiallyInside reference FTPlayer(source,target)
 */
private pattern mayInRelationinitiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pickUpColor reference FTPlayer(source,target)
 */
private pattern mustInRelationpickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pickUpColor reference FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pickUpColor reference FTPlayer(source,target)
 */
private pattern mayInRelationpickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpickUpColor_reference_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contains reference FTZone(source,target)
 */
private pattern mustInRelationcontains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contains reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contains reference FTZone(source,target)
 */
private pattern mayInRelationcontains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationcontains_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []partiallyOverlaps reference FTZone(source,target)
 */
private pattern mustInRelationpartiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"partiallyOverlaps reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>partiallyOverlaps reference FTZone(source,target)
 */
private pattern mayInRelationpartiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []isAdjacentTo reference FTZone(source,target)
 */
private pattern mustInRelationisAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isAdjacentTo reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>isAdjacentTo reference FTZone(source,target)
 */
private pattern mayInRelationisAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationisAdjacentTo_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disallowedPlayers reference FTZone(source,target)
 */
private pattern mustInRelationdisallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedPlayers reference FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disallowedPlayers reference FTZone(source,target)
 */
private pattern mayInRelationdisallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTPlayer_class(problem,interpretation,target);
} or {
	find mustInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []initiallyInside reference FTObstacle(source,target)
 */
private pattern mustInRelationinitiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>initiallyInside reference FTObstacle(source,target)
 */
private pattern mayInRelationinitiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disallowedZones reference FTObstacle(source,target)
 */
private pattern mustInRelationdisallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedZones reference FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disallowedZones reference FTObstacle(source,target)
 */
private pattern mayInRelationdisallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
} or {
	find mustInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []startZone reference FTZipline(source,target)
 */
private pattern mustInRelationstartZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"startZone reference FTZipline");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>startZone reference FTZipline(source,target)
 */
private pattern mayInRelationstartZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZipline_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstartZone_reference_FTZipline(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationstartZone_reference_FTZipline(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []endZone reference FTZipline(source,target)
 */
private pattern mustInRelationendZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"endZone reference FTZipline");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>endZone reference FTZipline(source,target)
 */
private pattern mayInRelationendZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZipline_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationendZone_reference_FTZipline(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationendZone_reference_FTZipline(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []toObject reference FTDistance(source,target)
 */
private pattern mustInRelationtoObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"toObject reference FTDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>toObject reference FTDistance(source,target)
 */
private pattern mayInRelationtoObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistance_class(problem,interpretation,source);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtoObject_reference_FTDistance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtoObject_reference_FTDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []player reference FTTrajectory(source,target)
 */
private pattern mustInRelationplayer_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"player reference FTTrajectory");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>player reference FTTrajectory(source,target)
 */
private pattern mayInRelationplayer_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTTrajectory_class(problem,interpretation,source);
	find mayInstanceOfFTPlayer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []states reference FTTrajectory(source,target)
 */
private pattern mustInRelationstates_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"states reference FTTrajectory");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>states reference FTTrajectory(source,target)
 */
private pattern mayInRelationstates_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTTrajectory_class(problem,interpretation,source);
	find mayInstanceOfFTState_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstates_reference_FTTrajectory(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []observations reference FTState(source,target)
 */
private pattern mustInRelationobservations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"observations reference FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>observations reference FTState(source,target)
 */
private pattern mayInRelationobservations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	find mayInstanceOfFTObservation_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationobservations_reference_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nextState reference FTState(source,target)
 */
private pattern mustInRelationnextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nextState reference FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nextState reference FTState(source,target)
 */
private pattern mayInRelationnextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	find mayInstanceOfFTState_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnextState_reference_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnextState_reference_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTDistanceObs(source,target)
 */
private pattern mustInRelationobject_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTDistanceObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTDistanceObs(source,target)
 */
private pattern mayInRelationobject_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,source);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTHangingObs(source,target)
 */
private pattern mustInRelationobject_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTHangingObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTHangingObs(source,target)
 */
private pattern mayInRelationobject_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTHangingObs_class(problem,interpretation,source);
	find mayInstanceOfFTZipline_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTHangingObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTHangingObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTPickUpObs(source,target)
 */
private pattern mustInRelationobject_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTPickUpObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTPickUpObs(source,target)
 */
private pattern mayInRelationobject_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,source);
	find mayInstanceOfFTObstacle_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []object reference FTZoneObs(source,target)
 */
private pattern mustInRelationobject_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTZoneObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>object reference FTZoneObs(source,target)
 */
private pattern mayInRelationobject_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZoneObs_class(problem,interpretation,source);
	find mayInstanceOfFTZone_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationobject_reference_FTZoneObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationobject_reference_FTZoneObs(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute FTStaticObject(source,target)
 */
private pattern mustInRelationname_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute FTStaticObject(source,target)
 */
private pattern mayInRelationname_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []size attribute FTStaticObject(source,target)
 */
private pattern mustInRelationsize_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"size attribute FTStaticObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>size attribute FTStaticObject(source,target)
 */
private pattern mayInRelationsize_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTStaticObject_class(problem,interpretation,source);
	find mayInstanceOfFTSize_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []role attribute FTPlayer(source,target)
 */
private pattern mustInRelationrole_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"role attribute FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>role attribute FTPlayer(source,target)
 */
private pattern mayInRelationrole_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	find mayInstanceOfFTRole_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrole_attribute_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrole_attribute_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []canPickUpObject attribute FTPlayer(source,target)
 */
private pattern mustInRelationcanPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"canPickUpObject attribute FTPlayer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>canPickUpObject attribute FTPlayer(source,target)
 */
private pattern mayInRelationcanPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPlayer_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []color attribute FTPickUpColorClass(source,target)
 */
private pattern mustInRelationcolor_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTPickUpColorClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>color attribute FTPickUpColorClass(source,target)
 */
private pattern mayInRelationcolor_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute FTZone(source,target)
 */
private pattern mustInRelationtype_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute FTZone");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute FTZone(source,target)
 */
private pattern mayInRelationtype_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTZone_class(problem,interpretation,source);
	find mayInstanceOfFTZoneType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_FTZone(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_FTZone(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []isMoveable attribute FTObstacle(source,target)
 */
private pattern mustInRelationisMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isMoveable attribute FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>isMoveable attribute FTObstacle(source,target)
 */
private pattern mayInRelationisMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []color attribute FTObstacle(source,target)
 */
private pattern mustInRelationcolor_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTObstacle");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>color attribute FTObstacle(source,target)
 */
private pattern mayInRelationcolor_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTObstacle_class(problem,interpretation,source);
	find mayInstanceOfFTPickUpColor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posX attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationposX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posX attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationposX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posY attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationposY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posY attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationposY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []sizeX attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationsizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeX attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>sizeX attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationsizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []sizeY attribute FTRealCoordinates(source,target)
 */
private pattern mustInRelationsizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeY attribute FTRealCoordinates");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>sizeY attribute FTRealCoordinates(source,target)
 */
private pattern mayInRelationsizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance attribute FTDistance(source,target)
 */
private pattern mustInRelationdistance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance attribute FTDistance(source,target)
 */
private pattern mayInRelationdistance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistance_class(problem,interpretation,source);
	find mayInstanceOfFTDistanceValue_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_attribute_FTDistance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_attribute_FTDistance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute FTState(source,target)
 */
private pattern mustInRelationname_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute FTState(source,target)
 */
private pattern mayInRelationname_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posX attribute FTState(source,target)
 */
private pattern mustInRelationposX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posX attribute FTState(source,target)
 */
private pattern mayInRelationposX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposX_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposX_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []posY attribute FTState(source,target)
 */
private pattern mustInRelationposY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTState");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>posY attribute FTState(source,target)
 */
private pattern mayInRelationposY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTState_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationposY_attribute_FTState(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationposY_attribute_FTState(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance attribute FTDistanceObs(source,target)
 */
private pattern mustInRelationdistance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistanceObs");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance attribute FTDistanceObs(source,target)
 */
private pattern mayInRelationdistance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,source);
	find mayInstanceOfFTDistanceValue_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,source,target); }or
	
	{ find mustInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,source,target); }or
	
	{ find mustInRelationcoordinates_reference_FTStaticObject(problem,interpretation,source,target); }or
	
	{ find mustInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,source,target); }or
	
	{ find mustInRelationpickUpColor_reference_FTPlayer(problem,interpretation,source,target); }or
	
	{ find mustInRelationstates_reference_FTTrajectory(problem,interpretation,source,target); }or
	
	{ find mustInRelationobservations_reference_FTState(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTHangingObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZipline_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPlayer_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObstacle_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZoneObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPickUpObs_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObservation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTDistance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTZone_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFTTrajectory_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FTDistance_class_by_initialDistances_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"initialDistances reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayInRelationinitialDistances_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class_by_distanceClass_reference_FTObjectWithDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"distanceClass reference FTObjectWithDistance");
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,container);
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayInRelationdistanceClass_reference_FTObjectWithDistance(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistance class");
	find mayInstanceOfFTDistance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTStaticObject_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTStaticObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTStaticObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTStaticObject class");
	find mayInstanceOfFTStaticObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZoneObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZoneObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTZoneObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZoneObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZoneObs class");
	find mayInstanceOfFTZoneObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObstacle_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObstacle class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTObstacle_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObstacle_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObstacle class");
	find mayInstanceOfFTObstacle_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistanceObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistanceObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTDistanceObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTDistanceObs class");
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTState_class_by_states_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"states reference FTTrajectory");
	find mustInstanceOfFTTrajectory_class(problem,interpretation,container);
	find mayInstanceOfFTState_class(problem,interpretation,newObject);
	find mayInRelationstates_reference_FTTrajectory(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTState class");
	find mayInstanceOfFTState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObjectWithDistance_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObjectWithDistance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObjectWithDistance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObjectWithDistance class");
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZipline_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZipline class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTZipline_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZipline_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZipline class");
	find mayInstanceOfFTZipline_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpColorClass_class_by_pickUpColor_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpColorClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pickUpColor reference FTPlayer");
	find mustInstanceOfFTPlayer_class(problem,interpretation,container);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,newObject);
	find mayInRelationpickUpColor_reference_FTPlayer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpColorClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpColorClass class");
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObservation_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObservation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTObservation_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTObservation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTObservation class");
	find mayInstanceOfFTObservation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPickUpObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPickUpObs class");
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTRealCoordinates_class_by_coordinates_reference_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTRealCoordinates class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"coordinates reference FTStaticObject");
	find mustInstanceOfFTStaticObject_class(problem,interpretation,container);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,newObject);
	find mayInRelationcoordinates_reference_FTStaticObject(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTRealCoordinates_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTRealCoordinates class");
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTHangingObs_class_by_observations_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTHangingObs class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"observations reference FTState");
	find mustInstanceOfFTState_class(problem,interpretation,container);
	find mayInstanceOfFTHangingObs_class(problem,interpretation,newObject);
	find mayInRelationobservations_reference_FTState(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTHangingObs_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTHangingObs class");
	find mayInstanceOfFTHangingObs_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Fairtracksmodel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Fairtracksmodel class");
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPlayer_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPlayer class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTPlayer_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTPlayer_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTPlayer class");
	find mayInstanceOfFTPlayer_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZone_class_by_staticObjects_reference_Fairtracksmodel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZone class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"staticObjects reference Fairtracksmodel");
	find mustInstanceOfFairtracksmodel_class(problem,interpretation,container);
	find mayInstanceOfFTZone_class(problem,interpretation,newObject);
	find mayInRelationstaticObjects_reference_Fairtracksmodel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTZone_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTZone class");
	find mayInstanceOfFTZone_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FTTrajectory_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FTTrajectory class");
	find mayInstanceOfFTTrajectory_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FTDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTStaticObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZoneObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
}
pattern refineTypeTo_FTObstacle_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTDistanceObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
}
pattern refineTypeTo_FTState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTObjectWithDistance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZipline_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPickUpColorClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTObservation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTObservation_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPickUpObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
}
pattern refineTypeTo_FTRealCoordinates_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTHangingObs_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTZoneObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTHangingObs_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistanceObs_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
}
pattern refineTypeTo_Fairtracksmodel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTPlayer_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTZone_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFTObstacle_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTPlayer_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTZipline_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTZone_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}
pattern refineTypeTo_FTTrajectory_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTDistance_class(problem,interpretation,element);
	neg find mustInstanceOfFTStaticObject_class(problem,interpretation,element);
	neg find mustInstanceOfFTRealCoordinates_class(problem,interpretation,element);
	neg find mustInstanceOfFairtracksmodel_class(problem,interpretation,element);
	neg find mustInstanceOfFTState_class(problem,interpretation,element);
	neg find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,element);
	neg find mustInstanceOfFTTrajectory_class(problem,interpretation,element);
	neg find mustInstanceOfFTObservation_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_initiallyInside_reference_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationinitiallyInside_reference_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_contains_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contains reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationcontains_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationcontains_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_partiallyOverlaps_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"partiallyOverlaps reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationpartiallyOverlaps_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_isAdjacentTo_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isAdjacentTo reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationisAdjacentTo_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationisAdjacentTo_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_disallowedPlayers_reference_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedPlayers reference FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTPlayer_class(problem,interpretation,to);
	find mayInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,from,to);
	neg find mustInRelationdisallowedPlayers_reference_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_initiallyInside_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"initiallyInside reference FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationinitiallyInside_reference_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_disallowedZones_reference_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disallowedZones reference FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationdisallowedZones_reference_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_startZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"startZone reference FTZipline");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZipline_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationstartZone_reference_FTZipline(problem,interpretation,from,to);
	neg find mustInRelationstartZone_reference_FTZipline(problem,interpretation,from,to);
}
pattern refineRelation_endZone_reference_FTZipline(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"endZone reference FTZipline");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZipline_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationendZone_reference_FTZipline(problem,interpretation,from,to);
	neg find mustInRelationendZone_reference_FTZipline(problem,interpretation,from,to);
}
pattern refineRelation_toObject_reference_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"toObject reference FTDistance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistance_class(problem,interpretation,from);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,to);
	find mayInRelationtoObject_reference_FTDistance(problem,interpretation,from,to);
	neg find mustInRelationtoObject_reference_FTDistance(problem,interpretation,from,to);
}
pattern refineRelation_player_reference_FTTrajectory(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"player reference FTTrajectory");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTTrajectory_class(problem,interpretation,from);
	find mustInstanceOfFTPlayer_class(problem,interpretation,to);
	find mayInRelationplayer_reference_FTTrajectory(problem,interpretation,from,to);
	neg find mustInRelationplayer_reference_FTTrajectory(problem,interpretation,from,to);
}
pattern refineRelation_nextState_reference_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nextState reference FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	find mustInstanceOfFTState_class(problem,interpretation,to);
	find mayInRelationnextState_reference_FTState(problem,interpretation,from,to);
	neg find mustInRelationnextState_reference_FTState(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTDistanceObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,from);
	find mustInstanceOfFTObjectWithDistance_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTDistanceObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTDistanceObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTHangingObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTHangingObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTHangingObs_class(problem,interpretation,from);
	find mustInstanceOfFTZipline_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTHangingObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTHangingObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTPickUpObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTPickUpObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPickUpObs_class(problem,interpretation,from);
	find mustInstanceOfFTObstacle_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTPickUpObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTPickUpObs(problem,interpretation,from,to);
}
pattern refineRelation_object_reference_FTZoneObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"object reference FTZoneObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZoneObs_class(problem,interpretation,from);
	find mustInstanceOfFTZone_class(problem,interpretation,to);
	find mayInRelationobject_reference_FTZoneObs(problem,interpretation,from,to);
	neg find mustInRelationobject_reference_FTZoneObs(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTStaticObject");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_FTStaticObject(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_FTStaticObject(problem,interpretation,from,to);
}
pattern refineRelation_size_attribute_FTStaticObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"size attribute FTStaticObject");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTStaticObject_class(problem,interpretation,from);
	find mustInstanceOfFTSize_enum(problem,interpretation,to);
	find mayInRelationsize_attribute_FTStaticObject(problem,interpretation,from,to);
	neg find mustInRelationsize_attribute_FTStaticObject(problem,interpretation,from,to);
}
pattern refineRelation_role_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"role attribute FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	find mustInstanceOfFTRole_enum(problem,interpretation,to);
	find mayInRelationrole_attribute_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationrole_attribute_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_canPickUpObject_attribute_FTPlayer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"canPickUpObject attribute FTPlayer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPlayer_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,from,to);
	neg find mustInRelationcanPickUpObject_attribute_FTPlayer(problem,interpretation,from,to);
}
pattern refineRelation_color_attribute_FTPickUpColorClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTPickUpColorClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTPickUpColorClass_class(problem,interpretation,from);
	find mustInstanceOfFTPickUpColor_enum(problem,interpretation,to);
	find mayInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,from,to);
	neg find mustInRelationcolor_attribute_FTPickUpColorClass(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_FTZone(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute FTZone");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTZone_class(problem,interpretation,from);
	find mustInstanceOfFTZoneType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_FTZone(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_FTZone(problem,interpretation,from,to);
}
pattern refineRelation_isMoveable_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"isMoveable attribute FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationisMoveable_attribute_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationisMoveable_attribute_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_color_attribute_FTObstacle(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"color attribute FTObstacle");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTObstacle_class(problem,interpretation,from);
	find mustInstanceOfFTPickUpColor_enum(problem,interpretation,to);
	find mayInRelationcolor_attribute_FTObstacle(problem,interpretation,from,to);
	neg find mustInRelationcolor_attribute_FTObstacle(problem,interpretation,from,to);
}
pattern refineRelation_posX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposX_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationposX_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_posY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposY_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationposY_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_sizeX_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeX attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationsizeX_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_sizeY_attribute_FTRealCoordinates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"sizeY attribute FTRealCoordinates");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTRealCoordinates_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,from,to);
	neg find mustInRelationsizeY_attribute_FTRealCoordinates(problem,interpretation,from,to);
}
pattern refineRelation_distance_attribute_FTDistance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistance_class(problem,interpretation,from);
	find mustInstanceOfFTDistanceValue_enum(problem,interpretation,to);
	find mayInRelationdistance_attribute_FTDistance(problem,interpretation,from,to);
	neg find mustInRelationdistance_attribute_FTDistance(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_posX_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posX attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposX_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationposX_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_posY_attribute_FTState(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"posY attribute FTState");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTState_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationposY_attribute_FTState(problem,interpretation,from,to);
	neg find mustInRelationposY_attribute_FTState(problem,interpretation,from,to);
}
pattern refineRelation_distance_attribute_FTDistanceObs(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute FTDistanceObs");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFTDistanceObs_class(problem,interpretation,from);
	find mustInstanceOfFTDistanceValue_enum(problem,interpretation,to);
	find mayInRelationdistance_attribute_FTDistanceObs(problem,interpretation,from,to);
	neg find mustInRelationdistance_attribute_FTDistanceObs(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////

//////////
// 1.2 Relation Declaration Indexers
//////////

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)

//////////
// 4.2 Type refinement
//////////

//////////
// 4.3 Relation refinement
//////////
