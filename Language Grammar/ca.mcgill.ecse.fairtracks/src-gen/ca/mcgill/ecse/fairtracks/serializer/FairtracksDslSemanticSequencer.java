/*
 * generated by Xtext 2.12.0
 */
package ca.mcgill.ecse.fairtracks.serializer;

import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTDistance;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTDistanceObs;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTHangingObs;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTObstacle;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTPickUpColorClass;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTPickUpObs;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTPlayer;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTRealCoordinates;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTState;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTTrajectory;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTZipline;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTZone;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FTZoneObs;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.FairtracksDslPackage;
import ca.mcgill.ecse.fairtracks.fairtracksDsl.Fairtracksmodel;
import ca.mcgill.ecse.fairtracks.services.FairtracksDslGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FairtracksDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FairtracksDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FairtracksDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FairtracksDslPackage.FT_DISTANCE:
				sequence_FTDistance(context, (FTDistance) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_DISTANCE_OBS:
				sequence_FTDistanceObs(context, (FTDistanceObs) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_HANGING_OBS:
				sequence_FTHangingObs(context, (FTHangingObs) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_OBSTACLE:
				sequence_FTObstacle(context, (FTObstacle) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_PICK_UP_COLOR_CLASS:
				sequence_FTPickUpColorClass(context, (FTPickUpColorClass) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_PICK_UP_OBS:
				sequence_FTPickUpObs(context, (FTPickUpObs) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_PLAYER:
				sequence_FTPlayer(context, (FTPlayer) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_REAL_COORDINATES:
				sequence_FTRealCoordinates(context, (FTRealCoordinates) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_STATE:
				sequence_FTState(context, (FTState) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_TRAJECTORY:
				sequence_FTTrajectory(context, (FTTrajectory) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_ZIPLINE:
				sequence_FTZipline(context, (FTZipline) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_ZONE:
				sequence_FTZone(context, (FTZone) semanticObject); 
				return; 
			case FairtracksDslPackage.FT_ZONE_OBS:
				sequence_FTZoneObs(context, (FTZoneObs) semanticObject); 
				return; 
			case FairtracksDslPackage.FAIRTRACKSMODEL:
				sequence_Fairtracksmodel(context, (Fairtracksmodel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     FTObservation returns FTDistanceObs
	 *     FTDistanceObs returns FTDistanceObs
	 *
	 * Constraint:
	 *     (distance=FTDistanceValue object=[FTObjectWithDistance|ID])
	 */
	protected void sequence_FTDistanceObs(ISerializationContext context, FTDistanceObs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE_OBS__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE_OBS__DISTANCE));
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE_OBS__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE_OBS__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTDistanceObsAccess().getDistanceFTDistanceValueEnumRuleCall_2_0(), semanticObject.getDistance());
		feeder.accept(grammarAccess.getFTDistanceObsAccess().getObjectFTObjectWithDistanceIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FairtracksDslPackage.Literals.FT_DISTANCE_OBS__OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FTDistance returns FTDistance
	 *
	 * Constraint:
	 *     (distance=FTDistanceValue toObject=[FTObjectWithDistance|ID])
	 */
	protected void sequence_FTDistance(ISerializationContext context, FTDistance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE__DISTANCE));
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE__TO_OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_DISTANCE__TO_OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTDistanceAccess().getDistanceFTDistanceValueEnumRuleCall_1_0(), semanticObject.getDistance());
		feeder.accept(grammarAccess.getFTDistanceAccess().getToObjectFTObjectWithDistanceIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FairtracksDslPackage.Literals.FT_DISTANCE__TO_OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FTObservation returns FTHangingObs
	 *     FTHangingObs returns FTHangingObs
	 *
	 * Constraint:
	 *     object=[FTZipline|ID]
	 */
	protected void sequence_FTHangingObs(ISerializationContext context, FTHangingObs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_HANGING_OBS__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_HANGING_OBS__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTHangingObsAccess().getObjectFTZiplineIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FairtracksDslPackage.Literals.FT_HANGING_OBS__OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FTStaticObject returns FTObstacle
	 *     FTObjectWithDistance returns FTObstacle
	 *     FTObstacle returns FTObstacle
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         size=FTSize 
	 *         isMoveable?='isMoveable'? 
	 *         color=FTPickUpColor 
	 *         initiallyInside=[FTZone|ID]? 
	 *         (disallowedZones+=[FTZone|ID] disallowedZones+=[FTZone|ID]*)? 
	 *         distanceClass+=FTDistance* 
	 *         coordinates=FTRealCoordinates?
	 *     )
	 */
	protected void sequence_FTObstacle(ISerializationContext context, FTObstacle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTPickUpColorClass returns FTPickUpColorClass
	 *
	 * Constraint:
	 *     color=FTPickUpColor
	 */
	protected void sequence_FTPickUpColorClass(ISerializationContext context, FTPickUpColorClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_PICK_UP_COLOR_CLASS__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_PICK_UP_COLOR_CLASS__COLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTPickUpColorClassAccess().getColorFTPickUpColorEnumRuleCall_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FTObservation returns FTPickUpObs
	 *     FTPickUpObs returns FTPickUpObs
	 *
	 * Constraint:
	 *     object=[FTObstacle|ID]
	 */
	protected void sequence_FTPickUpObs(ISerializationContext context, FTPickUpObs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_PICK_UP_OBS__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_PICK_UP_OBS__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTPickUpObsAccess().getObjectFTObstacleIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FairtracksDslPackage.Literals.FT_PICK_UP_OBS__OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FTStaticObject returns FTPlayer
	 *     FTObjectWithDistance returns FTPlayer
	 *     FTPlayer returns FTPlayer
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         size=FTSize 
	 *         role=FTRole 
	 *         initiallyInside=[FTZone|ID]? 
	 *         canPickUpObject?='canPickUp'? 
	 *         (pickUpColor+=FTPickUpColorClass pickUpColor+=FTPickUpColorClass*)? 
	 *         distanceClass+=FTDistance* 
	 *         coordinates=FTRealCoordinates?
	 *     )
	 */
	protected void sequence_FTPlayer(ISerializationContext context, FTPlayer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTRealCoordinates returns FTRealCoordinates
	 *
	 * Constraint:
	 *     (posX=INT posY=INT sizeX=INT sizeY=INT)
	 */
	protected void sequence_FTRealCoordinates(ISerializationContext context, FTRealCoordinates semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__POS_X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__POS_X));
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__POS_Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__POS_Y));
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__SIZE_X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__SIZE_X));
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__SIZE_Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_REAL_COORDINATES__SIZE_Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTRealCoordinatesAccess().getPosXINTTerminalRuleCall_3_0(), semanticObject.getPosX());
		feeder.accept(grammarAccess.getFTRealCoordinatesAccess().getPosYINTTerminalRuleCall_5_0(), semanticObject.getPosY());
		feeder.accept(grammarAccess.getFTRealCoordinatesAccess().getSizeXINTTerminalRuleCall_11_0(), semanticObject.getSizeX());
		feeder.accept(grammarAccess.getFTRealCoordinatesAccess().getSizeYINTTerminalRuleCall_13_0(), semanticObject.getSizeY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FTState returns FTState
	 *
	 * Constraint:
	 *     (name=ID posX=INT posY=INT observations+=FTObservation* nextState=[FTState|ID]?)
	 */
	protected void sequence_FTState(ISerializationContext context, FTState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTTrajectory returns FTTrajectory
	 *
	 * Constraint:
	 *     (player=[FTPlayer|ID] states+=FTState*)
	 */
	protected void sequence_FTTrajectory(ISerializationContext context, FTTrajectory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTStaticObject returns FTZipline
	 *     FTZipline returns FTZipline
	 *
	 * Constraint:
	 *     (name=ID size=FTSize startZone=[FTZone|ID] endZone=[FTZone|ID] coordinates=FTRealCoordinates?)
	 */
	protected void sequence_FTZipline(ISerializationContext context, FTZipline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FTObservation returns FTZoneObs
	 *     FTZoneObs returns FTZoneObs
	 *
	 * Constraint:
	 *     object=[FTZone|ID]
	 */
	protected void sequence_FTZoneObs(ISerializationContext context, FTZoneObs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairtracksDslPackage.Literals.FT_ZONE_OBS__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairtracksDslPackage.Literals.FT_ZONE_OBS__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFTZoneObsAccess().getObjectFTZoneIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FairtracksDslPackage.Literals.FT_ZONE_OBS__OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FTStaticObject returns FTZone
	 *     FTObjectWithDistance returns FTZone
	 *     FTZone returns FTZone
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         size=FTSize 
	 *         type=FTZoneType 
	 *         (contains+=[FTZone|ID] contains+=[FTZone|ID]*)? 
	 *         (partiallyOverlaps+=[FTZone|ID] partiallyOverlaps+=[FTZone|ID]*)? 
	 *         (isAdjacentTo+=[FTZone|ID] isAdjacentTo+=[FTZone|ID]*)? 
	 *         (disallowedPlayers+=[FTPlayer|ID] disallowedPlayers+=[FTPlayer|ID]*)? 
	 *         distanceClass+=FTDistance* 
	 *         coordinates=FTRealCoordinates?
	 *     )
	 */
	protected void sequence_FTZone(ISerializationContext context, FTZone semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fairtracksmodel returns Fairtracksmodel
	 *
	 * Constraint:
	 *     ((staticObjects+=FTStaticObject+ initialDistances+=FTDistance+) | initialDistances+=FTDistance+)?
	 */
	protected void sequence_Fairtracksmodel(ISerializationContext context, Fairtracksmodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
